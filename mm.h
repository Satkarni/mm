//
// Created by Nishant Kelkar on 3/14/21.
//
#ifndef MM_MM_H
#define MM_MM_H

#define MAZE_SIZE     16
#define N  (1<<0)
#define E  (1<<1)
#define S  (1<<2)
#define W  (1<<3)

/* Orientation that the mouse is pointing in (N, E, W, S) */
typedef enum {
  _n,
  _e,
  _w,
  _s
} dir;

struct mm_pose {
  int x;
  int y;
  int mx;
  int my;
  dir curr_direction;
};

/**
 * Cell details, including the wall bit-map info. For example:
 * North => wbm = 0b0001
 * East => wbm = 0b0010
 * South => wbm = 0b0100
 * West => wbm = 0b1000
 * North and East => wbm = 0b0011
 * ...
 * If wbm = 0b0001 for a particular cell instance, that means
 * that there is a wall to the North of this cell.
 */
struct cell {
  int x;
  int y;
  short wbm;    // Wall bit-map
  bool visited; // Used in flood fill
  int value;
};

// Goal cells (center cells): (7,7) (7,8) (8,7) (8,8)
// Start cell: (0,15)
struct maze {
  struct cell cells[MAZE_SIZE][MAZE_SIZE];
};

/**
 * North wall only -> 0x01
 * East wall only  -> 0x02
 * South wall only -> 0x04
 * West wall only  -> 0x08
 *
 * Note that the maze format is transposed w.r.t. the physical maze!
 * That is, the index mappings from a value in this array and a physical
 * maze (16 x 16 standard) are as follows:
 * index 0 => (0, 15)
 * index 1 => (0, 14)
 * index 2 => (0, 13)
 * index 3 => (0, 12)
 * ...
 * index 16 => (1, 15)
 * index 17 => (1, 14)
 * ...
 * This assumes that the (0, 0) position in the physical maze is the
 * top-left cell and +ve x-direction is rightwards, and +ve y-direction
 * is downwards.
 */
int cur_maze[] = {
  0x0E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x09,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
  0x06, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03,
};

#endif //MM_MM_H
